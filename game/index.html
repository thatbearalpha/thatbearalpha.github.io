<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bear Alpha Runner</title>
  <style>
    :root{
      --game-size: 400px;
      --ui-width: 400px;
    }
    html,body{
      height:100%;
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      background:#fff;
      color:#000;
      overflow:hidden; /* make page unscrollable */
      -webkit-user-select:none;
      -ms-user-select:none;
      user-select:none;
      touch-action:none;
    }

    .page{
      max-width:760px;
      margin:18px auto;
      padding:18px;
      text-align:center;
    }

    h1{ font-size:24px; font-weight:800; margin:0 0 6px 0; }

    .link{
      display:inline-block;
      color:#2563eb;
      text-decoration:underline;
      margin:8px 0 14px;
    }

    /* Game area */
    #gameContainer{
      position:relative;
      width:var(--game-size);
      height:var(--game-size);
      margin:20px auto;
      background:#f0f0f0;
      border:3px solid #000;
      overflow:hidden;
      touch-action:none;
    }

    .entity{
      position:absolute;
      width:20px;
      height:20px;
      will-change: transform;
    }

    #player{ background:blue; left:50px; top:50px; }
    #killer{ background:red; left:300px; top:300px; }
    #wall{
      position:absolute;
      left:175px;
      top:100px;
      width:50px;
      height:200px;
      background:#333;
    }

    /* Sprint & health UI */
    .sprint-bar{
      width:var(--ui-width);
      height:6px;
      margin:12px auto 6px;
      background:#ddd;
      border:1px solid #000;
      position:relative;
    }
    .sprint-fill{
      position:absolute; left:0; top:0; height:100%; width:100%;
      background:#60a5fa; transition:width 0.08s linear;
    }

    .bar-container{
      width:var(--ui-width);
      height:25px;
      background:#ddd;
      border:2px solid #000;
      margin:6px auto 10px;
      display:flex;
      overflow:hidden;
    }
    .bar-section{
      flex:1;
      background:#4ade80;
      transition:transform 0.35s;
      transform:translateY(0%);
    }

    /* Controls layout */
    .controls{
      width:var(--ui-width);
      margin:12px auto;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }

    /* Joystick */
    .joystick {
      position:relative;
      width:120px;
      height:120px;
      border-radius:999px;
      background:rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      border:2px solid rgba(0,0,0,0.12);
      touch-action:none;
    }
    .joy-knob{
      width:56px;
      height:56px;
      border-radius:999px;
      background:#e5e7eb;
      border:2px solid #000;
      transform:translate(0,0);
      transition: background .06s;
      touch-action:none;
    }
    .joy-active .joy-knob{ background:#cbd5e1; }

    /* Sprint button */
    .sprint-button{
      width:120px;
      height:60px;
      background:#93c5fd;
      border:2px solid #000;
      border-radius:8px;
      font-weight:700;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      touch-action:none;
      user-select:none;
    }
    .sprint-button:active{ background:#60a5fa; }

    /* position controls bottom-left/right */
    .controls-wrapper{
      position:relative;
      height:120px;
    }
    .left-controls{ position:absolute; left:0; bottom:0; }
    .right-controls{ position:absolute; right:0; bottom:0; }

    /* Small layout fixes for smaller screens */
    @media (max-width:440px){
      :root{ --game-size: 360px; --ui-width: 360px; }
      .joystick{ width:100px; height:100px; }
      .joy-knob{ width:48px; height:48px; }
      .sprint-button{ width:100px; height:56px; }
    }
  </style>
</head>
<body>
  <div class="page">
    <h1>Bear Alpha Runner</h1>
    <a class="link" href="/">‚Üê Back to Home</a>

    <div id="gameContainer" aria-hidden="false">
      <div id="player" class="entity" aria-hidden="false"></div>
      <div id="killer" class="entity" aria-hidden="false"></div>
      <div id="wall" aria-hidden="false"></div>
    </div>

    <div class="sprint-bar" aria-hidden="true">
      <div id="sprintFill" class="sprint-fill"></div>
    </div>

    <div class="bar-container" id="healthBar" aria-hidden="true">
      <div class="bar-section"></div>
      <div class="bar-section"></div>
      <div class="bar-section"></div>
      <div class="bar-section"></div>
    </div>

    <div class="controls-wrapper" style="width:var(--ui-width); margin:0 auto;">
      <div class="left-controls">
        <div id="joystick" class="joystick" aria-label="Movement joystick" role="application">
          <div class="joy-knob" id="joyKnob"></div>
        </div>
      </div>

      <div class="right-controls">
        <div id="sprintBtn" class="sprint-button" role="button" aria-pressed="false">Sprint</div>
      </div>
    </div>
  </div>

  <script>
    // Elements
    const playerEl = document.getElementById('player');
    const killerEl = document.getElementById('killer');
    const wallEl = document.getElementById('wall');
    const sprintFillEl = document.getElementById('sprintFill');
    const barSections = document.querySelectorAll('.bar-section');

    // Positions (in px inside game container)
    let playerX = 50, playerY = 50;
    let killerX = 300, killerY = 300;

    // Game vars
    let health = 4;
    let sprint = 100; // percent
    let sprinting = false;
    const playerBaseSpeed = 3;   // normal speed
    const playerSprintSpeed = 5; // when sprinting
    const killerMaxStep = 3.2;
    let lastTime = performance.now();
    let debounce = false;

    // Input state
    const input = { x: 0, y: 0 }; // -1..1 vector from joystick or keyboard
    const keys = { up:false, down:false, left:false, right:false };

    const container = document.getElementById('gameContainer');

    // Utility: detect rect intersection (all coordinates relative to game area)
    function rectsIntersect(x1,y1,w1,h1, x2,y2,w2,h2){
      return !(x1 + w1 <= x2 || x1 >= x2 + w2 || y1 + h1 <= y2 || y1 >= y2 + h2);
    }

    // Get wall rect relative to container
    function getWallRect(){
      return {
        x: wallEl.offsetLeft,
        y: wallEl.offsetTop,
        w: wallEl.offsetWidth,
        h: wallEl.offsetHeight
      };
    }

    // --- Joystick (pointer events) ---
    const joystick = document.getElementById('joystick');
    const knob = document.getElementById('joyKnob');

    let joyCenter = { x: 0, y: 0 };
    let maxRadius = 0;
    let activePointerId = null;

    function recalcJoystickMetrics(){
      const r = joystick.getBoundingClientRect();
      const k = knob.getBoundingClientRect();
      joyCenter = { x: r.left + r.width/2, y: r.top + r.height/2 };
      maxRadius = Math.max(0, (r.width - k.width) / 2);
    }

    // initial calc and on resize
    recalcJoystickMetrics();
    window.addEventListener('resize', recalcJoystickMetrics);

    function setKnobPosition(dx, dy){
      knob.style.transform = `translate(${dx}px, ${dy}px)`;
    }
    function resetJoystick(){
      input.x = 0; input.y = 0;
      setKnobPosition(0,0);
      joystick.classList.remove('joy-active');
      activePointerId = null;
    }

    function onPointerDown(e){
      // Only handle primary pointers if joystick not already active
      if (activePointerId !== null) return;
      activePointerId = e.pointerId;
      try { joystick.setPointerCapture(activePointerId); } catch(_) {}
      joystick.classList.add('joy-active');
      recalcJoystickMetrics();
      onPointerMove(e); // handle initial position
      e.preventDefault();
    }

    function onPointerMove(e){
      if (activePointerId === null || e.pointerId !== activePointerId) return;
      const dx = e.clientX - joyCenter.x;
      const dy = e.clientY - joyCenter.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const clampedDist = Math.min(dist, maxRadius);
      const angle = Math.atan2(dy, dx);
      const nx = Math.cos(angle);
      const ny = Math.sin(angle);
      // normalized input in -1..1
      input.x = (clampedDist / (maxRadius || 1)) * nx;
      input.y = (clampedDist / (maxRadius || 1)) * ny;
      setKnobPosition(nx * clampedDist, ny * clampedDist);
      e.preventDefault();
    }

    function onPointerUp(e){
      if (activePointerId === null || e.pointerId !== activePointerId) return;
      try { joystick.releasePointerCapture(activePointerId); } catch(_) {}
      resetJoystick();
      e.preventDefault();
    }

    joystick.addEventListener('pointerdown', onPointerDown, {passive:false});
    window.addEventListener('pointermove', onPointerMove, {passive:false});
    window.addEventListener('pointerup', onPointerUp, {passive:false});
    window.addEventListener('pointercancel', onPointerUp, {passive:false});

    // Desktop keyboard WASD controls
    window.addEventListener('keydown', (e) => {
      if(e.code === 'KeyW') keys.up = true;
      if(e.code === 'KeyS') keys.down = true;
      if(e.code === 'KeyA') keys.left = true;
      if(e.code === 'KeyD') keys.right = true;
      if(e.key === 'Shift') sprinting = true;
      // prevent page scroll keys interfering
      if(['KeyW','KeyA','KeyS','KeyD','ShiftLeft','ShiftRight'].includes(e.code) || e.key === 'Shift'){
        e.preventDefault();
      }
      updateInputFromKeys();
    }, {passive:false});

    window.addEventListener('keyup', (e) => {
      if(e.code === 'KeyW') keys.up = false;
      if(e.code === 'KeyS') keys.down = false;
      if(e.code === 'KeyA') keys.left = false;
      if(e.code === 'KeyD') keys.right = false;
      if(e.key === 'Shift') sprinting = false;
      updateInputFromKeys();
    });

    function updateInputFromKeys(){
      // Only apply keyboard input when joystick is not active
      if(activePointerId !== null) return;
      const x = (keys.right?1:0) - (keys.left?1:0);
      const y = (keys.down?1:0) - (keys.up?1:0);
      const mag = Math.sqrt(x*x + y*y) || 1;
      input.x = (mag === 0) ? 0 : x / mag;
      input.y = (mag === 0) ? 0 : y / mag;
      setKnobPosition(input.x * (maxRadius*0.6), input.y * (maxRadius*0.6));
    }

    // Sprint button (pointer)
    const sprintBtn = document.getElementById('sprintBtn');
    sprintBtn.addEventListener('pointerdown', (e) => { sprinting = true; sprintBtn.setAttribute('aria-pressed','true'); e.preventDefault(); });
    window.addEventListener('pointerup', ()=>{ sprinting = false; sprintBtn.setAttribute('aria-pressed','false'); });

    // Movement / physics loop
    function clampPlayerPosition(){
      playerX = Math.max(0, Math.min(container.clientWidth - 20, playerX));
      playerY = Math.max(0, Math.min(container.clientHeight - 20, playerY));
    }

    function canMoveRect(x,y,w,h){
      const wall = getWallRect();
      return !rectsIntersect(x,y,w,h, wall.x, wall.y, wall.w, wall.h);
    }

    function gameLoop(now){
      const dt = Math.min(50, now - lastTime); // ms, clamp for stability
      lastTime = now;

      // apply input vector (joystick or keyboard)
      let inX = input.x;
      let inY = input.y;
      // If small deadzone, ignore jitter
      const deadzone = 0.12;
      if(Math.abs(inX) < deadzone) inX = 0;
      if(Math.abs(inY) < deadzone) inY = 0;

      // compute speed with sprint
      const isSprinting = sprinting && sprint > 0;
      const speed = isSprinting ? playerSprintSpeed : playerBaseSpeed;
      const moveStep = (speed * (dt/16)); // scaled to 60fps ~16ms

      // Normalize direction
      const mag = Math.sqrt(inX*inX + inY*inY);
      let dx = 0, dy = 0;
      if(mag > 0){
        dx = (inX / mag) * moveStep;
        dy = (inY / mag) * moveStep;
      }

      // Attempt move with collision against wall
      const nextPX = playerX + dx;
      const nextPY = playerY + dy;
      const playerSize = 20;
      if(canMoveRect(nextPX, playerY, playerSize, playerSize)) playerX = nextPX;
      // separate axis resolution for smoother sliding
      if(canMoveRect(playerX, nextPY, playerSize, playerSize)) playerY = nextPY;

      clampPlayerPosition();

      // Killer movement: head towards player but do not move into wall
      const kdx = playerX - killerX;
      const kdy = playerY - killerY;
      const kdist = Math.sqrt(kdx*kdx + kdy*kdy);
      if(kdist > 0.5){
        const step = killerMaxStep * (dt/16); // scale similarly
        const kstepX = (kdx / kdist) * step;
        const kstepY = (kdy / kdist) * step;

        // Try move X then Y with wall collision checks
        const nextKX = killerX + kstepX;
        const nextKY = killerY + kstepY;
        const killerSize = 20;
        // try both axes individually (simple sliding)
        if(canMoveRect(nextKX, killerY, killerSize, killerSize)) killerX = nextKX;
        if(canMoveRect(killerX, nextKY, killerSize, killerSize)) killerY = nextKY;
        // If both blocked, killer stays (so they won't go through wall)
      }

      // Update DOM positions
      playerEl.style.transform = `translate(${playerX}px, ${playerY}px)`;
      killerEl.style.transform = `translate(${killerX}px, ${killerY}px)`;

      // Collision between player & killer -> damage with debounce
      const playerRect = { x: playerX, y: playerY, w:20, h:20 };
      const killerRect = { x: killerX, y: killerY, w:20, h:20 };
      if(rectsIntersect(playerRect.x, playerRect.y, playerRect.w, playerRect.h,
                        killerRect.x, killerRect.y, killerRect.w, killerRect.h) && !debounce){
        debounce = true;
        health = Math.max(0, health - 1);
        // animate the health section sliding
        if(health >= 0 && health < barSections.length){
          barSections[health].style.transform = 'translateY(100%)';
        }
        setTimeout(()=> debounce = false, 1000);
      }

      // Sprint drain/regeneration (use dt for smoothness)
      if(sprinting && sprint > 0){
        sprint = Math.max(0, sprint - (2 * (dt/100)));
      } else if(!sprinting && sprint < 100){
        sprint = Math.min(100, sprint + (1 * (dt/100)));
      }
      sprintFillEl.style.width = sprint + '%';

      requestAnimationFrame(gameLoop);
    }

    // Start loop
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);

    // Reset health visuals on load (in case)
    for(let i=0;i<barSections.length;i++) barSections[i].style.transform = 'translateY(0%)';

    // Safety: when leaving pointer (like switching apps), reset joystick and sprint
    window.addEventListener('blur', () => { resetJoystick(); sprinting=false; });

    // Prevent touch scrolling in game area
    container.addEventListener('touchstart', (e)=> e.preventDefault(), {passive:false});
  </script>
</body>
</html>
